#package /ospl/log/durability

// Tokens (regular expressions)
x/token number:           "[0-9]+", type = uint32
x/token identifier:       "[a-zA-Z_][a-zA-Z_0-9]*"
x/token bool:             "true|false|TRUE|FALSE|True|False"
x/token groupIdentifier:  "[a-zA-Z_0-9\\. -]+"
x/token durabilityKind:   "VOLATILE|TRANSIENT|PERSISTENT"
x/token list:             "[a-zA-Z_0-9\\. -,]*"

// Patterns
x/pattern time:           "{sec:number}.{nanosec:number}", type = core/time
x/pattern header:         "{t:time} {state:identifier} ({identifier}) ->"
x/pattern fellow:         "{value:number}", type = uint32
x/pattern namespace:      "{value:identifier}", type = string
x/pattern group:          "{value:groupIdentifier}", type = string
x/pattern conflict:       "{value:number}", type = int32
x/pattern mergeState:     "({role:identifier},{state:number})"

// Parser with rules for each line that must be matched
x/parser parser::
  // Fellow rules
  x/rule me:                    "{:header} My address is: '{:fellow}'"
  x/rule fellowNew:             "{:header} Confirmed fellow {:fellow} added to admin."
  x/rule fellowLost:            "{:header} Removing confirmed fellow {:fellow}"
  x/rule fellowConflictNew:     "{:header} Fellow connect conflict for fellow {:fellow} detected, conflict {:conflict} created"
  x/rule fellowTimeOffset:      "{:header} Estimated time difference including latency with fellow {:fellow} is {:time} seconds."
  x/rule fellowLostCheckMaster: "{:header} Fellow '{:fellow}' removed, checking whether new master must be determined."
  x/rule fellowLostCheckRequests: "{:header} Fellow removed, checking {:fellow} requests."
  x/rule fellowRequestsLeft:    "{:header} {requestCount:number} requests left."
  x/rule fellowNsReceived:      "{:header} Received {count:number} of {total:number} nameSpaces from fellow {:fellow}."
  x/rule fellowNsComplete:      "{:header} Fellow nameSpaces complete."
  x/rule fellowAsymDisconnect:  "{:header} Fellow {:fellow} was asymmetrically disconnected from me, I may have published data that was missed by the fellow."
  x/rule fellowDisconnectConflict: "{:header} Fellow disconnect conflict for fellow {:fellow} detected, conflict {:conflict} created"
  x/rule fellowAsymReestablish: "{:header} Reestablish connection with asymmetrically disconnected fellow {:fellow}."

  // Conflict rules
  x/rule conflictStart:         "{:header} Start resolving conflict {:conflict}"
  x/rule conflictStop:          "{:header} Stop resolving conflict {:conflict}"
  x/rule conflictTry:           "{:header} Trying to resolve conflict {:conflict}"
  x/rule conflictMasterDiscard: "{:header} I have no confirmed master for namespace {:namespace}, discarding conflict {:conflict}"

  // Namespace rules
  x/rule nsReceived:            "{:header} Received nameSpace '{:namespace}' from fellow {:fellow} (his master: {master:fellow}, confirmed: {confirmed:number}, mergeState: {:mergeState}, quality: {quality:time}, mergedStates:\\{{mergedStates:list}\\}, extensions: \\{{extensions:list}\\})."
  x/rule nsRequestReceived:     "{:header} Received nameSpacesRequest from fellow {:fellow}."
  x/rule nsMasterConfirmed:     "{:header} Confirming master: Fellow '{:fellow}' is the master for nameSpace '{:namespace}'."
  x/rule nsIAmMaster:           "{:header} Confirming master: I am the master for nameSpace '{:namespace}'." 
  x/rule nsMasterConflictNew:   "{:header} Master conflict in namespace '{:namespace}' for fellow {:fellow} detected, conflict {:conflict} created"
  x/rule nsMasterFinding:       "{:header} Need to find a new master for nameSpace '{:namespace}'."
  x/rule nsRequestFromFellows:  "{:header} Requesting fellow namespaces..."

  // Group rules
  x/rule groupFound:            "{:header} Group found: {:group} ({:durabilityKind})"
  x/rule groupIgnore:           "{:header} Ignoring group {:group}."
  x/rule groupComplete:         "{:header} Group {:group} is now complete."
  x/rule groupAttach:           "{:header} Service '{service:identifier}' has attached to group {:group}."
  x/rule groupReport:           "{:header} Reporting group {:group}, kind: {kind:number}, completeness: {completeness:number}"
  x/rule groupWaiting:          "{:header} Waiting for group '{:group}' to be created."
  x/rule groupTryAligner:       "{:header} Trying to find aligner again for {groupCount:number} groups."
  x/rule groupWaitAligner:      "{:header} Still waiting for alignment of {groupCount:number} groups."
  x/rule groupsRequestReceived: "{:header} Received groupsRequest from fellow {:fellow}; sending all groups"
  x/rule groupsSending:         "{:header} Sending {groupCount:number} groups"
  x/rule groupsSent:            "{:header} All local groups sent to fellow"
  x/rule groupNoAlignerMaster:  "{:header} Group {:group} will not be aligned until the master fellow becomes complete (reportGroupWhenUnfullfilled={reportGroupWhenUnfullfilled:bool}, notInitial={notInitial:bool})."
  x/rule groupNotAligning:      "{:header} Group {:group} will not be aligned until an aligner fellow becomes available."
  x/rule groupAdministrating:   "{:header} Administrating group {:group}."
  x/rule groupSendingTo:        "{:header} Now sending data for group {:group} to fellow(s) {:fellow}."
  x/rule groupSendingNoSamples: "{:header} Sending no samples for group {:group} to fellow {:fellow}."
  x/rule groupNoRequestNeeded:  "{:header} No need to request groups from fellow {:fellow}"
  x/rule groupRemoteReceived:   "{:header} Received remote group '{:group}' with completeness={completeness:number} and quality={quality:time} from fellow: {:fellow}."
  x/rule groupRemoveReceivedUnknown: "{:header} Received remote group {:group} which is locally unknown."  
  x/rule groupRemoteRegistered: "{:header} Remote group '{:group}' with completeness={completeness:number} and quality={quality:time} registered for fellow {:fellow}."
  x/rule groupWaitCompleteness: "{:header} Group '{:group}' is available. Waiting for completeness..."

  // Sample requests
  x/rule sampleRequestReceived: "{:header} Received sample request for group {:group} from fellow {:fellow} using source ({number},{number},{number}), adding it to queue."
  x/rule sampleRequestQueued:   "{:header} Sample request for group {:group} from fellow {:fellow} added to queue."
  x/rule sampleRequestFinished: "{:header} Sent {sampleCount:number} samples for group {:group} to fellow {:fellow} ({fellowCount:number} fellows total)."
  x/rule sampleRequestSummary:  "{:header} WRITE: {write:number}, DISPOSED: {disposed:number}, WRITE_DISPOSED: {writedisposed:number}, REGISTER: {register:number}, UNREGISTER: {unregister:number} (SKIPPED: {skipped:number})"
  x/rule sampleChainUnrequested:"{:header} Received unrequested chain message for group '{:group}' from fellow {:fellow} for {fellowCount:number} fellows: {fellows:list}"

  // All matched rules will be forwarded to this rule for generic processing
  x/rule _matched{}

struct period::
  from: core/time
  to: core/time

// Type that keeps track of when a fellow was alive
struct fellowTracker::
  class fellow::
    id: int32
    alive: list{period}

  void new(int32 fellowId, core/time time)
  int16 lost(int32 fellowId, core/time time)
  fellow find(int32 fellowId)

  fellows: list{fellow}

// Generate HTML from logfile
x/visitor htmlVisitor: durability/parser::
  void destruct() method
  x/callback fellowNew{}
  x/callback fellowLost{}

  member tracker: fellowTracker, readonly
